                              Crypt Technologie

     Это  исходники  одной  моей  мысли,  разумеется,  так  и не доведенной до
логического конца. Я больше, чем уверен, даже убежден, что сей зверек содержит
тысячу баг, которые еще нужно было бы отлавливать... Но не в этом дело. Дело в
технологии. Технология заключается вот в чем: Байт может принимать значения от
000h   до   0ffh.  Сопоставим  каждому  возможному  значению  байта  случайное
уникальное значение слова. Получим таблицу
                            Table dw 0ffh dup (?)
     В  таблицу заносим случайные слова, но каждый раз проверяем уникальность,
то  есть,  чтобы  такого слова в таблице еще не было. Собственно, из этих слов
будем в дальнейшем составлять тело зверушки.
     После   того,   как  сформировали  таблицу,  берем  по  одному  байту  из
буфера-тушки.  Значение  байта  является  индексом  в  нашей таблице. Умножаем
значение  байта  на  2  (так как таблица в словах). Берем из таблицы элемент с
индексом, равным полученному значению и пишем его в выходной буфер.
     Обратная  операция  аналогична.  Берем  из  входного  буфера  слово, ищем
соответствие ему в таблице. Индекс соответствующего элемента пихаем в выходной
буфер - он и есть исходный байт тушки.
     Короче, все просто до безобразия... но красиво ;-)

                                              (c) Pr0cedure pr0cedure@chat.ru
